import fr.acinq.lightning.db.IncomingPayment;

-- incoming payments
CREATE TABLE incoming_payments (
    id TEXT NOT NULL PRIMARY KEY,
    payment_hash BLOB UNIQUE,
    created_at INTEGER NOT NULL,
    received_at INTEGER DEFAULT NULL,
    json TEXT AS IncomingPayment NOT NULL
);

CREATE INDEX incoming_payments_payment_hash_idx ON incoming_payments(payment_hash);

-- Create indexes to optimize the queries in AggregatedQueries.
-- Tip: Use "explain query plan" to ensure they're actually being used.
CREATE INDEX incoming_payments_filter_idx
    ON incoming_payments(received_at)
 WHERE received_at IS NOT NULL;

-- queries

insert:
INSERT INTO incoming_payments (
            id,
            payment_hash,
            created_at,
            received_at,
            json)
VALUES (?, ?, ?, ?, ?);

updateReceived:
UPDATE incoming_payments
SET    received_at=?,
       json=?
WHERE  id = ?;

get:
SELECT *
FROM   incoming_payments
WHERE  id=?;

getByPaymentHash:
SELECT *
FROM   incoming_payments
WHERE  payment_hash=?;

getOldestReceivedDate:
SELECT   received_at
FROM     incoming_payments AS r
WHERE    received_at IS NOT NULL
ORDER BY r.received_at ASC
LIMIT 1;

listReceivedWithin:
SELECT payment.*, meta.external_id
FROM   incoming_payments AS payment
LEFT OUTER JOIN payments_metadata AS meta ON meta.type = 1 AND meta.id = lower(hex(payment.payment_hash))
WHERE  received_at IS NOT NULL AND received_at BETWEEN :from AND :to
ORDER BY
        coalesce(received_at, payment.created_at) DESC,
        payment_hash DESC
LIMIT :limit OFFSET :offset;

listReceivedForExternalIdWithin:
SELECT payment.*, meta.external_id
FROM   incoming_payments AS payment
LEFT OUTER JOIN payments_metadata AS meta ON meta.type = 1 AND meta.id = lower(hex(payment.payment_hash))
WHERE  meta.external_id = :externalId AND received_at IS NOT NULL AND received_at BETWEEN :from AND :to
ORDER BY
        coalesce(received_at, payment.created_at) DESC,
        payment_hash DESC
LIMIT :limit OFFSET :offset;

listCreatedWithin:
SELECT payment.json, meta.external_id
FROM   incoming_payments AS payment
LEFT OUTER JOIN payments_metadata AS meta ON meta.type = 1 AND meta.id = lower(hex(payment.payment_hash))
WHERE  payment.created_at BETWEEN :from AND :to
ORDER BY
       coalesce(received_at, payment.created_at) DESC,
       payment_hash DESC
LIMIT :limit OFFSET :offset;

listCreatedForExternalIdWithin:
SELECT payment.json, meta.external_id
FROM   incoming_payments AS payment
LEFT OUTER JOIN payments_metadata AS meta ON meta.type = 1 AND meta.id = lower(hex(payment.payment_hash))
WHERE  meta.external_id = :externalId
AND    payment.created_at BETWEEN :from AND :to
ORDER BY
       coalesce(received_at, payment.created_at) DESC,
       payment_hash DESC
LIMIT :limit OFFSET :offset;

listCreatedWithinNoPaging:
SELECT json
FROM   incoming_payments
WHERE  created_at BETWEEN :from AND :to
ORDER BY
       coalesce(received_at, created_at) DESC,
       payment_hash DESC;

listAllNotConfirmed:
SELECT json
FROM   incoming_payments
LEFT OUTER JOIN link_tx_to_payments
    ON link_tx_to_payments.type = 1
    AND link_tx_to_payments.confirmed_at IS NULL
    AND link_tx_to_payments.id = incoming_payments.payment_hash
WHERE received_at IS NOT NULL;

scanCompleted:
SELECT payment_hash,
       received_at
FROM   incoming_payments
WHERE  received_at IS NOT NULL;

delete:
DELETE FROM incoming_payments
WHERE payment_hash = ?;

-- use this in a `transaction` block to know how many rows were changed after an UPDATE
changes:
SELECT changes();
